饿汉式:
优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。
缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存

懒汉式加锁:
优点:被外部类调用的时候内部类才会加载
缺点:上锁，对程序性能还是存在一定影响

懒汉式double check:
优点:被外部类调用的时候内部类才会加载
缺点:

懒汉式静态内部类:
这种形式兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题.

注册式单例之 枚举：
​	jdk1.5之后出现的枚举，枚举实现单例是饿汉式单例的实现。是在静态代码块中就给new了对象。

​	优点：枚举式单例不进避免了多线程同步的问题，而且还能防止 反射、序列化反序列化对造成的破坏。

​	缺点： 看不到源码。

注册式单例之容器缓存方式实现单例：
​	跟懒汉式优点类似，都是需要加锁来实现线程安全的

​	优点： 容器式写法适用于创建实例非常多的情况，便于管理

​	缺点：加了锁，效率会稍微低点。

ThreadLocal实现单例：
    ThreadLocal是将所有的对象放在ThreadLocalMap中，为每一个线程提供一个对象。就是以空间换时间来实现线程间间隔的


破坏单例的方法：反射、序列化
一、通过反射来破坏单例：
​	反射可以在类运行的时候获取到它的私有构造器，然后通过构造器调用getInstance() 获得类的对象，而且是不同的实例。在静态内部类实现单例的方式中可以用下边方式来防止反射破坏单例。（InnerClass.lazyInnerClassSingleton != null 这个永远是true， 只要调用私有构造就会进异常）

二、序列化和反序列化来破坏单例：
​	当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例。 (反序列化之后是重新创建了一个对象，与之前的不是同一个，所以破坏了单例)

​	解决方法：

​	增加 readResolve()方法返回实例，可以解决了单例被破坏的问题。但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。 实例化两次会消耗没存。

​	枚举类型实现单例， 在反序列化的时候是通过类名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。

